


# Design Patterns


Creational Patterns
Abstract Factory Pattern
Builder Pattern - Allows you to create different flavors of an object while avoiding constructor pollution. Useful when there could be several flavors of an object. Or when there are a lot of steps involved in creation of an object.
Factory Method Pattern
Prototype Pattern
Singleton Pattern


Structural Patterns (or Interface Patterns)
Concerned with how objects are made up and simplify relationships between objects.
Either extend functionality (Decorator) or simplifies functionality (Flyweight, Facade).
Adapter Pattern - Converts the interface of a class into another interface the clients expect. Adapter lets classes work together that couldnâ€™t otherwise because of incompatible interfaces.
Facade Pattern - Used to provide a simplified interface to a complicated system
Bridge Pattern - Decouple an abstraction from its implementation so that the two can vary independently
Composite Pattern - Define an interface that applies to individual objects and groups of objects
Decorator Pattern - Used to add new functionality to an existing object without being obtrusive. Wraps an object.
Flyweight Pattern - Conserves memory by sharing portions of an object between objects.
Proxy Pattern (Surrogate)- Provide a surrogate or placeholder for another object o control


Behavioral Patterns - Concerned with how objects interact with one another. We want to have loose coupling
Chain of Responsibility Pattern (CoR)
Command Pattern
Interpreter Pattern
Iterator Pattern - Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation
Mediator Pattern - Controls communication between objects so neither objects has to be coupled to the others.
Memento Pattern
Observer Pattern
State Pattern - Allows an object to alter its behavior when its internal state changes. The object will appear to change its class.
Strategy Pattern
Template Method Pattern
Visitor Pattern - Separate algorithm from object
Template Pattern - Defines the steps of an algorithm and allows subclasses to provide the implementation for one or more steps.